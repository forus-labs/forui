<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JSON Code Viewer</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: flex;
      height: 100vh;
      background: #1e1e1e;
      color: #d4d4d4;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      background: #252526;
      border-right: 1px solid #3c3c3c;
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .sidebar-header {
      padding: 16px;
      font-size: 14px;
      font-weight: 600;
      color: #ccc;
      border-bottom: 1px solid #3c3c3c;
    }

    .search-box {
      padding: 12px 16px;
      border-bottom: 1px solid #3c3c3c;
    }

    .search-box input {
      width: 100%;
      padding: 8px 12px;
      background: #3c3c3c;
      border: 1px solid #555;
      border-radius: 4px;
      color: #fff;
      font-size: 13px;
    }

    .search-box input::placeholder { color: #888; }
    .search-box input:focus { outline: none; border-color: #0e639c; }

    .nav-container {
      flex: 1;
      overflow-y: auto;
    }

    .group { border-bottom: 1px solid #3c3c3c; }

    .group-header {
      padding: 10px 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
      color: #e0e0e0;
      user-select: none;
    }

    .group-header:hover { background: #2a2d2e; }
    .group-header::before { content: '\25b6'; font-size: 10px; transition: transform 0.2s; }
    .group.open .group-header::before { transform: rotate(90deg); }

    .group-items { display: none; background: #1e1e1e; }
    .group.open .group-items { display: block; }

    .nav-item {
      padding: 8px 16px 8px 32px;
      cursor: pointer;
      font-size: 13px;
      color: #9cdcfe;
      text-decoration: none;
      display: block;
    }

    .nav-item:hover { background: #2a2d2e; }
    .nav-item.active { background: #094771; color: #fff; }

    .nav-hint {
      padding: 12px 16px;
      font-size: 11px;
      color: #666;
      border-top: 1px solid #3c3c3c;
    }

    .nav-hint kbd {
      background: #3c3c3c;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: inherit;
    }

    /* Main content */
    .main {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .empty-state {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #666;
      font-size: 14px;
    }

    .code-section {
      scroll-margin-top: 20px;
    }

    .code-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #3c3c3c;
      flex-wrap: wrap;
    }

    .code-title {
      font-size: 18px;
      font-weight: 600;
      color: #4fc3f7;
    }

    .code-path {
      font-size: 12px;
      color: #888;
      flex: 1;
    }

    .btn {
      padding: 4px 12px;
      background: #3c3c3c;
      color: #ccc;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .btn:hover { background: #505050; }
    .btn.copied { background: #2e7d32; color: #fff; }

    /* Code block with line numbers */
    .code-block {
      background: #1e1e1e;
      border: 1px solid #3c3c3c;
      border-radius: 6px;
      overflow: hidden;
      font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
      font-size: 14px;
      line-height: 1.5;
    }

    .code-table {
      width: 100%;
      border-collapse: collapse;
    }

    .line {
      transition: background-color 0.15s;
    }

    .line:hover {
      background: rgba(255, 255, 255, 0.03);
    }

    .line.highlighted {
      background: rgba(78, 201, 176, 0.15);
    }

    .line.highlighted:hover {
      background: rgba(78, 201, 176, 0.2);
    }

    .line.selected {
      background: rgba(255, 213, 79, 0.15);
    }

    .line.selected:hover {
      background: rgba(255, 213, 79, 0.2);
    }

    .line-number {
      width: 1%;
      min-width: 50px;
      padding: 0 12px;
      text-align: right;
      color: #5a5a5a;
      user-select: none;
      cursor: pointer;
      vertical-align: top;
      border-right: 1px solid #3c3c3c;
    }

    .line-number:hover {
      color: #888;
    }

    .line.highlighted .line-number {
      color: #4ec9b0;
    }

    .line.selected .line-number {
      color: #ffd54f;
    }

    .line-content {
      padding: 0 16px;
      white-space: pre;
      overflow-x: auto;
    }

    .line-content a {
      color: #4ec9b0;
      text-decoration: underline;
      text-decoration-style: dotted;
    }

    .line-content a:hover {
      color: #9cdcfe;
    }

    .loading {
      color: #888;
      padding: 20px;
    }

    /* Tooltips */
    .tooltip-trigger {
      text-decoration: underline;
      text-decoration-style: dotted;
      text-decoration-color: #888;
    }

    .tooltip-popup {
      position: fixed;
      max-width: 750px;
      max-height: 500px;
      overflow-y: auto;
      background: #2d2d2d;
      border: 1px solid #555;
      border-radius: 6px;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      z-index: 1000;
      font-size: 13px;
      line-height: 1.5;
    }

    .tooltip-popup .tooltip-code {
      font-family: 'Fira Code', 'Consolas', monospace;
      background: #1e1e1e;
      padding: 8px 12px;
      border-radius: 4px;
      margin-bottom: 8px;
      white-space: pre-wrap;
      color: #d4d4d4;
    }

    .tooltip-popup .tooltip-code a {
      color: #4ec9b0;
      text-decoration: underline;
      text-decoration-style: dotted;
    }

    .tooltip-popup .tooltip-code a:hover {
      color: #9cdcfe;
    }

    .tooltip-popup .tooltip-container {
      font-size: 11px;
      color: #888;
      margin-bottom: 8px;
    }

    .tooltip-popup .tooltip-container a {
      color: #4ec9b0;
    }

    .tooltip-popup .tooltip-docs {
      color: #ccc;
    }

    .tooltip-popup .tooltip-docs code {
      background: #3c3c3c;
      padding: 1px 4px;
      border-radius: 3px;
      font-family: 'Fira Code', 'Consolas', monospace;
    }

    /* Variant selectors for usages files */
    .variant-selectors {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-bottom: 16px;
      padding: 12px 16px;
      background: #252526;
      border: 1px solid #3c3c3c;
      border-radius: 6px;
    }

    .variant-selector {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .variant-selector label {
      font-size: 11px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .variant-selector select {
      padding: 6px 28px 6px 10px;
      background: #3c3c3c url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23888' d='M2 4l4 4 4-4z'/%3E%3C/svg%3E") no-repeat right 8px center;
      border: 1px solid #555;
      border-radius: 4px;
      color: #fff;
      font-size: 13px;
      font-family: 'Fira Code', 'Consolas', monospace;
      cursor: pointer;
      appearance: none;
      min-width: 200px;
    }

    .variant-selector select:hover {
      border-color: #777;
    }

    .variant-selector select:focus {
      outline: none;
      border-color: #0e639c;
    }

    .variant-description {
      font-size: 12px;
      color: #888;
      margin-top: 2px;
      max-width: 300px;
    }

    .variant-toggle {
      padding: 6px 14px;
      background: #3c3c3c;
      border: 1px solid #555;
      border-radius: 4px;
      color: #888;
      font-size: 13px;
      font-family: 'Fira Code', 'Consolas', monospace;
      cursor: pointer;
    }

    .variant-toggle:hover {
      border-color: #777;
    }

    .variant-toggle.on {
      background: #094771;
      border-color: #0e639c;
      color: #fff;
    }
  </style>
</head>
<body>
  <nav class="sidebar">
    <div class="sidebar-header">JSON Viewer</div>
    <div class="search-box">
      <input type="text" id="search" placeholder="Filter... (/)">
    </div>
    <div class="nav-container" id="nav">
      <div class="loading">Loading...</div>
    </div>
    <div class="nav-hint">
      <kbd>&uarr;</kbd><kbd>&darr;</kbd> nav
      <kbd>Enter</kbd> go
      <kbd>/</kbd> search
    </div>
  </nav>

  <main class="main" id="main">
    <div class="empty-state">Select a file from the sidebar</div>
  </main>

  <script>
    const BASE = '/samples';
    let allFiles = [];
    let currentFile = null;
    let currentData = null;
    let lastClickedLine = null;
    let variantSelections = {}; // Track selected variant index per category

    // Check if data is a usages file (has categories)
    function isUsagesFile(data) {
      return data && data.categories && Object.keys(data.categories).length > 0;
    }

    // Build merged code by substituting {{category}} placeholders with selected variants
    function buildMergedCode(data, selections) {
      if (!isUsagesFile(data)) {
        return { text: data.text, links: data.links || [], tooltips: data.tooltips || [] };
      }

      let text = data.text;
      let links = (data.links || []).map(l => ({...l}));
      let tooltips = (data.tooltips || []).map(t => ({...t}));

      // Find all {{category}} placeholders and their positions
      const placeholderRegex = /\{\{([^}]+)\}\}/g;
      const placeholders = [];
      let match;
      while ((match = placeholderRegex.exec(data.text)) !== null) {
        placeholders.push({
          category: match[1],
          start: match.index,
          end: match.index + match[0].length,
          length: match[0].length
        });
      }

      // Sort by position (reverse to handle offset adjustments correctly)
      placeholders.sort((a, b) => b.start - a.start);

      // Substitute each placeholder
      for (const ph of placeholders) {
        const variants = data.categories[ph.category];
        if (!variants || variants.length === 0) continue;

        const selectedIndex = selections[ph.category] ?? 0;

        // -1 means "none" - remove placeholder entirely
        const variant = selectedIndex === -1 ? null : variants[selectedIndex];
        const variantText = variant?.text || '';

        const start = ph.start;
        const end = ph.end;

        // Calculate offset adjustment
        const adjustment = variantText.length - (end - start);

        // Substitute in text
        text = text.substring(0, start) + variantText + text.substring(end);

        // Adjust links that come after this placeholder
        for (const link of links) {
          if (link.offset >= end) {
            link.offset += adjustment;
          }
        }
        for (const tip of tooltips) {
          if (tip.offset >= end) {
            tip.offset += adjustment;
          }
        }

        // Add variant's links/tooltips (offset adjusted to placeholder position)
        if (variant) {
          for (const link of (variant.links || [])) {
            links.push({ ...link, offset: link.offset + ph.start });
          }
          for (const tip of (variant.tooltips || [])) {
            tooltips.push({ ...tip, offset: tip.offset + ph.start });
          }
        }
      }

      return { text, links, tooltips };
    }

    // Render variant selector dropdowns (or toggle if only 1 option)
    function renderVariantSelectors(categories, selections) {
      const categoryNames = Object.keys(categories);
      if (categoryNames.length === 0) return '';

      return `<div class="variant-selectors">${categoryNames.map(name => {
        const variants = categories[name];
        const selected = selections[name] ?? 0;
        const selectedVariant = variants[selected];
        const description = selected === -1 ? '' : (selectedVariant?.description || '');

        // Single variant: render toggle button
        if (variants.length === 1) {
          const isOn = selected === 0;
          return `
            <div class="variant-selector">
              <label>${escapeHtml(name)}</label>
              <button class="variant-toggle${isOn ? ' on' : ''}" data-category="${escapeHtml(name)}">${escapeHtml(variants[0].name)}</button>
              ${description ? `<div class="variant-description">${escapeHtml(description)}</div>` : ''}
            </div>
          `;
        }

        // Multiple variants: render dropdown with none option
        return `
          <div class="variant-selector">
            <label>${escapeHtml(name)}</label>
            <select data-category="${escapeHtml(name)}">
              <option value="-1"${selected === -1 ? ' selected' : ''}>none</option>
              ${variants.map((v, i) => `<option value="${i}"${i === selected ? ' selected' : ''}>${escapeHtml(v.name)}</option>`).join('')}
            </select>
            ${description ? `<div class="variant-description">${escapeHtml(description)}</div>` : ''}
          </div>
        `;
      }).join('')}</div>`;
    }

    // Handle variant selection change (dropdown)
    function onVariantChange(e) {
      const category = e.target.dataset.category;
      const index = parseInt(e.target.value);
      variantSelections[category] = index;
      rerenderUsagesCode();
    }

    // Handle toggle button click (single variant)
    function onToggleClick(e) {
      const category = e.target.dataset.category;
      const current = variantSelections[category] ?? 0;
      variantSelections[category] = current === 0 ? -1 : 0;
      e.target.classList.toggle('on');
      rerenderUsagesCode();
    }

    // Re-render only the code block for usages files
    function rerenderUsagesCode() {
      if (!currentData || !isUsagesFile(currentData)) return;

      const merged = buildMergedCode(currentData, variantSelections);
      const codeContainer = document.querySelector('.code-block');
      if (codeContainer) {
        codeContainer.outerHTML = renderCode(merged.text, merged.links, currentData.highlights, merged.tooltips);
        // Re-setup tooltips and line handlers
        setupTooltips(merged.tooltips);
        document.querySelectorAll('.line-number').forEach(ln => {
          ln.addEventListener('click', handleLineClick);
        });
        applyHighlightFromHash();
      }

      // Update descriptions
      document.querySelectorAll('.variant-selector').forEach(selector => {
        const cat = selector.querySelector('select').dataset.category;
        const idx = variantSelections[cat] || 0;
        const variant = currentData.categories[cat][idx];
        const descEl = selector.querySelector('.variant-description');
        if (variant.description) {
          if (descEl) {
            descEl.textContent = variant.description;
          } else {
            selector.insertAdjacentHTML('beforeend', `<div class="variant-description">${escapeHtml(variant.description)}</div>`);
          }
        } else if (descEl) {
          descEl.remove();
        }
      });
    }

    // Fetch file list from server
    async function loadFileList() {
      const res = await fetch('/api/files');
      return res.json();
    }

    // Fetch individual JSON file
    async function loadFile(path) {
      const res = await fetch(`${BASE}/${path}`);
      return res.json();
    }

    // Escape HTML entities
    function escapeHtml(s) {
      return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    // Render text with links applied (helper for renderLineWithAnnotations)
    // insideTooltip: if true, don't add title attribute (avoid double tooltip)
    function renderWithLinks(text, links, baseOffset, insideTooltip = false) {
      const relevantLinks = links.filter(link =>
        link.start < baseOffset + text.length && link.end > baseOffset
      );

      if (!relevantLinks.length) return escapeHtml(text);

      relevantLinks.sort((a, b) => a.start - b.start);

      let result = '';
      let pos = 0;

      for (const link of relevantLinks) {
        const start = Math.max(0, link.start - baseOffset);
        const end = Math.min(text.length, link.end - baseOffset);

        if (start < pos) continue; // Skip overlapping links

        if (start > pos) {
          result += escapeHtml(text.slice(pos, start));
        }

        const titleAttr = insideTooltip ? '' : ` title="${escapeHtml(link.data.url)}"`;
        result += `<a href="${escapeHtml(link.data.url)}" target="_blank"${titleAttr}>${escapeHtml(text.slice(start, end))}</a>`;
        pos = end;
      }

      if (pos < text.length) {
        result += escapeHtml(text.slice(pos));
      }

      return result;
    }

    // Render source code with links and tooltips applied to a single line
    // Tooltips are outer spans, links can be nested inside them
    function renderLineWithAnnotations(lineText, links, tooltips, lineStartOffset) {
      const lineEndOffset = lineStartOffset + lineText.length;

      // Convert links to line-relative coordinates
      const lineLinks = [];
      for (const link of (links || [])) {
        if (link.offset < lineEndOffset && (link.offset + link.length) > lineStartOffset) {
          lineLinks.push({
            start: Math.max(0, link.offset - lineStartOffset),
            end: Math.min(lineText.length, link.offset + link.length - lineStartOffset),
            data: link
          });
        }
      }

      // Convert tooltips to line-relative coordinates
      const lineTooltips = [];
      for (let i = 0; i < (tooltips || []).length; i++) {
        const tip = tooltips[i];
        if (tip.offset < lineEndOffset && (tip.offset + tip.length) > lineStartOffset) {
          lineTooltips.push({
            start: Math.max(0, tip.offset - lineStartOffset),
            end: Math.min(lineText.length, tip.offset + tip.length - lineStartOffset),
            data: tip,
            index: i
          });
        }
      }

      if (!lineTooltips.length && !lineLinks.length) return escapeHtml(lineText);

      // If no tooltips, just render with links
      if (!lineTooltips.length) {
        return renderWithLinks(lineText, lineLinks, 0);
      }

      // Sort tooltips by start position
      lineTooltips.sort((a, b) => a.start - b.start);

      let result = '';
      let pos = 0;

      for (const tooltip of lineTooltips) {
        // Skip overlapping tooltips
        if (tooltip.start < pos) continue;

        // Add text before this tooltip (with links)
        if (tooltip.start > pos) {
          result += renderWithLinks(lineText.slice(pos, tooltip.start), lineLinks, pos);
        }

        // Render tooltip content with contained links (no title attr to avoid double tooltip)
        const tooltipText = lineText.slice(tooltip.start, tooltip.end);
        const tooltipContent = renderWithLinks(tooltipText, lineLinks, tooltip.start, true);
        result += `<span class="tooltip-trigger" data-tooltip="${tooltip.index}">${tooltipContent}</span>`;

        pos = tooltip.end;
      }

      // Add remaining text (with links)
      if (pos < lineText.length) {
        result += renderWithLinks(lineText.slice(pos), lineLinks, pos);
      }

      return result;
    }

    // Render code block with line numbers
    function renderCode(code, links, highlights, tooltips) {
      const lines = code.split('\n');
      let offset = 0;

      // Build set of highlighted line numbers
      const highlightedLines = new Set();
      for (const h of (highlights || [])) {
        for (let i = h.start; i <= h.end; i++) {
          highlightedLines.add(i);
        }
      }

      const rows = lines.map((line, i) => {
        const lineNum = i + 1;
        const content = renderLineWithAnnotations(line, links, tooltips, offset);
        offset += line.length + 1; // +1 for newline
        const isHighlighted = highlightedLines.has(lineNum);

        return `<tr class="line${isHighlighted ? ' highlighted' : ''}" data-line="${lineNum}">
          <td class="line-number" data-line="${lineNum}">${lineNum}</td>
          <td class="line-content">${content || ' '}</td>
        </tr>`;
      });

      return `<div class="code-block"><table class="code-table"><tbody>${rows.join('')}</tbody></table></div>`;
    }

    // Group files by directory (all path segments except filename)
    function groupFiles(files) {
      const groups = {};
      for (const f of files) {
        const parts = f.split('/');
        const group = parts.slice(0, -1).join('/');
        (groups[group] ??= []).push(f);
      }
      return groups;
    }

    // Build sidebar navigation
    function buildNav(files, filter = '') {
      const nav = document.getElementById('nav');
      const filtered = files.filter(f => !filter || f.toLowerCase().includes(filter.toLowerCase()));
      const groups = groupFiles(filtered);

      if (Object.keys(groups).length === 0) {
        nav.innerHTML = '<div class="loading">No matches</div>';
        return;
      }

      const { filePath } = parseHash();

      nav.innerHTML = Object.entries(groups).map(([group, items]) => {
        const isOpen = items.some(f => f === filePath) || filter;
        return `
          <div class="group${isOpen ? ' open' : ''}">
            <div class="group-header">${group} (${items.length})</div>
            <div class="group-items">
              ${items.map(f => {
                const name = f.split('/').pop().replace('.json', '');
                const isActive = f === filePath;
                return `<a class="nav-item${isActive ? ' active' : ''}" href="#${f}" data-path="${f}">${name}</a>`;
              }).join('')}
            </div>
          </div>
        `;
      }).join('');

      // Add click handlers for group headers
      nav.querySelectorAll('.group-header').forEach(header => {
        header.addEventListener('click', () => {
          header.parentElement.classList.toggle('open');
        });
      });
    }

    // Parse URL hash for file path and line range
    function parseHash() {
      const hash = decodeURIComponent(location.hash.slice(1));
      const match = hash.match(/^(.+?\.json)(?::L(\d+)(?:-L?(\d+))?)?$/);

      if (!match) return { filePath: hash, startLine: null, endLine: null };

      return {
        filePath: match[1],
        startLine: match[2] ? parseInt(match[2]) : null,
        endLine: match[3] ? parseInt(match[3]) : (match[2] ? parseInt(match[2]) : null)
      };
    }

    // Build hash from file path and line range
    function buildHash(filePath, startLine, endLine) {
      if (!startLine) return filePath;
      if (startLine === endLine) return `${filePath}:L${startLine}`;
      return `${filePath}:L${startLine}-L${endLine}`;
    }

    // Show content for a file
    async function showFile(filePath) {
      if (!filePath || !allFiles.includes(filePath)) return;

      currentFile = filePath;
      variantSelections = {}; // Reset selections for new file
      const main = document.getElementById('main');

      try {
        currentData = await loadFile(filePath);
        const parts = filePath.split('/');
        const name = parts.pop().replace('.json', '');
        const group = parts.join('/');

        // Check if this is a usages file with categories
        const isUsages = isUsagesFile(currentData);
        let codeText, codeLinks, codeTooltips;

        if (isUsages) {
          const merged = buildMergedCode(currentData, variantSelections);
          codeText = merged.text;
          codeLinks = merged.links;
          codeTooltips = merged.tooltips;
        } else {
          codeText = currentData.text || '';
          codeLinks = currentData.links;
          codeTooltips = currentData.tooltips;
        }

        main.innerHTML = `
          <section class="code-section" id="${filePath}">
            <div class="code-header">
              <span class="code-title">${group}/${name}</span>
              <span class="code-path">${BASE}/${filePath}</span>
              <button class="btn" id="copyLinkBtn">Copy Link</button>
              <button class="btn" id="copyCodeBtn">Copy Code</button>
            </div>
            ${isUsages ? renderVariantSelectors(currentData.categories, variantSelections) : ''}
            ${renderCode(codeText, codeLinks, currentData.highlights, codeTooltips)}
          </section>
        `;

        // Add button handlers
        document.getElementById('copyLinkBtn').addEventListener('click', copyLink);
        document.getElementById('copyCodeBtn').addEventListener('click', copyCode);

        // Add variant selector handlers
        if (isUsages) {
          main.querySelectorAll('.variant-selector select').forEach(sel => {
            sel.addEventListener('change', onVariantChange);
          });
          main.querySelectorAll('.variant-toggle').forEach(btn => {
            btn.addEventListener('click', onToggleClick);
          });
        }

        // Add line click handlers
        main.querySelectorAll('.line-number').forEach(ln => {
          ln.addEventListener('click', handleLineClick);
        });

        // Add tooltip handlers
        setupTooltips(codeTooltips || []);

        // Apply highlighting from hash
        applyHighlightFromHash();

      } catch (e) {
        main.innerHTML = `<div class="empty-state">Error loading ${filePath}: ${e.message}</div>`;
      }
    }

    // Simple markdown to HTML conversion
    function renderMarkdown(md) {
      if (!md) return '';
      return md
        .replace(/`([^`]+)`/g, '<code>$1</code>')
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        .replace(/\*([^*]+)\*/g, '<em>$1</em>')
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>')
        .replace(/\n\n/g, '<br><br>')
        .replace(/\n/g, ' ');
    }

    // Setup tooltip handlers
    let activeTooltip = null;
    let tooltipHideTimeout = null;
    const TOOLTIP_DURATION = 100; // 100ms

    function setupTooltips(tooltips) {
      document.querySelectorAll('.tooltip-trigger').forEach(el => {
        const index = parseInt(el.dataset.tooltip);
        const tip = tooltips[index];
        if (!tip) return;

        el.addEventListener('mouseenter', (e) => showTooltip(e, tip));
        el.addEventListener('mouseleave', scheduleHideTooltip);
      });
    }

    // Render tooltip code with links
    function renderTooltipCode(code, links) {
      if (!links || !links.length) return escapeHtml(code);

      // Sort links by offset
      const sorted = [...links].sort((a, b) => a.offset - b.offset);

      let result = '';
      let pos = 0;

      for (const link of sorted) {
        const start = link.offset;
        const end = link.offset + link.length;

        if (start < pos) continue; // Skip overlapping

        if (start > pos) {
          result += escapeHtml(code.slice(pos, start));
        }

        result += `<a href="${escapeHtml(link.url)}" target="_blank">${escapeHtml(code.slice(start, end))}</a>`;
        pos = end;
      }

      if (pos < code.length) {
        result += escapeHtml(code.slice(pos));
      }

      return result;
    }

    function showTooltip(e, tip) {
      // Cancel any pending hide
      if (tooltipHideTimeout) {
        clearTimeout(tooltipHideTimeout);
        tooltipHideTimeout = null;
      }

      // Remove existing tooltip
      if (activeTooltip) {
        activeTooltip.remove();
        activeTooltip = null;
      }

      const popup = document.createElement('div');
      popup.className = 'tooltip-popup';

      const snippet = tip.snippet || {};
      let html = `<div class="tooltip-code">${renderTooltipCode(snippet.text || '', snippet.links)}</div>`;

      if (snippet.container) {
        html += `<div class="tooltip-container">in <a href="${escapeHtml(snippet.container.url)}" target="_blank">${escapeHtml(snippet.container.name)}</a></div>`;
      }

      if (tip.documentation) {
        html += `<div class="tooltip-docs">${renderMarkdown(tip.documentation)}</div>`;
      }

      popup.innerHTML = html;
      document.body.appendChild(popup);

      // Keep tooltip visible when cursor is inside it
      popup.addEventListener('mouseenter', () => {
        if (tooltipHideTimeout) {
          clearTimeout(tooltipHideTimeout);
          tooltipHideTimeout = null;
        }
      });
      // Immediately hide when leaving the popup
      popup.addEventListener('mouseleave', hideTooltip);

      // Position the tooltip
      const rect = e.target.getBoundingClientRect();
      const popupRect = popup.getBoundingClientRect();

      let left = rect.left;
      let top = rect.bottom + 8;

      // Keep within viewport
      if (left + popupRect.width > window.innerWidth - 20) {
        left = window.innerWidth - popupRect.width - 20;
      }
      if (top + popupRect.height > window.innerHeight - 20) {
        top = rect.top - popupRect.height - 8;
      }

      popup.style.left = `${Math.max(10, left)}px`;
      popup.style.top = `${top}px`;

      activeTooltip = popup;
    }

    function scheduleHideTooltip() {
      if (tooltipHideTimeout) {
        clearTimeout(tooltipHideTimeout);
      }
      tooltipHideTimeout = setTimeout(hideTooltip, TOOLTIP_DURATION);
    }

    function hideTooltip() {
      if (tooltipHideTimeout) {
        clearTimeout(tooltipHideTimeout);
        tooltipHideTimeout = null;
      }
      if (activeTooltip) {
        activeTooltip.remove();
        activeTooltip = null;
      }
    }

    // Handle line number click
    function handleLineClick(e) {
      const lineNum = parseInt(e.target.dataset.line);

      if (e.shiftKey && lastClickedLine !== null) {
        // Range selection
        const start = Math.min(lastClickedLine, lineNum);
        const end = Math.max(lastClickedLine, lineNum);
        location.hash = buildHash(currentFile, start, end);
      } else {
        // Single line selection
        lastClickedLine = lineNum;
        location.hash = buildHash(currentFile, lineNum, lineNum);
      }
    }

    // Apply selection highlighting based on URL hash
    function applyHighlightFromHash() {
      const { startLine, endLine } = parseHash();

      // Clear existing selection
      document.querySelectorAll('.line.selected').forEach(el => {
        el.classList.remove('selected');
      });

      if (startLine === null) return;

      // Apply new selection
      for (let i = startLine; i <= endLine; i++) {
        const line = document.querySelector(`.line[data-line="${i}"]`);
        if (line) {
          line.classList.add('selected');
          if (i === startLine) {
            line.scrollIntoView({ block: 'center', behavior: 'smooth' });
          }
        }
      }
    }

    // Copy link to clipboard
    function copyLink() {
      const btn = document.getElementById('copyLinkBtn');
      navigator.clipboard.writeText(location.href);
      btn.textContent = 'Copied!';
      btn.classList.add('copied');
      setTimeout(() => {
        btn.textContent = 'Copy Link';
        btn.classList.remove('copied');
      }, 1500);
    }

    // Copy code to clipboard
    function copyCode() {
      const btn = document.getElementById('copyCodeBtn');
      navigator.clipboard.writeText(currentData?.text || '');
      btn.textContent = 'Copied!';
      btn.classList.add('copied');
      setTimeout(() => {
        btn.textContent = 'Copy Code';
        btn.classList.remove('copied');
      }, 1500);
    }

    // Update active nav item
    function updateActiveNav() {
      const { filePath } = parseHash();
      document.querySelectorAll('.nav-item').forEach(el => {
        el.classList.toggle('active', el.dataset.path === filePath);
        if (el.dataset.path === filePath) {
          el.closest('.group')?.classList.add('open');
        }
      });
    }

    // Handle hash change
    async function handleHashChange() {
      const { filePath } = parseHash();

      if (filePath !== currentFile) {
        await showFile(filePath);
      } else {
        applyHighlightFromHash();
      }

      updateActiveNav();
    }

    // Keyboard navigation
    document.addEventListener('keydown', e => {
      const searchInput = document.getElementById('search');

      // Focus search on /
      if (e.key === '/' && document.activeElement !== searchInput) {
        e.preventDefault();
        searchInput.focus();
        return;
      }

      // Clear search on Escape
      if (e.key === 'Escape') {
        searchInput.blur();
        searchInput.value = '';
        buildNav(allFiles);
        return;
      }

      // Arrow navigation
      if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
        e.preventDefault();
        const items = [...document.querySelectorAll('.group.open .nav-item')];
        if (!items.length) return;

        const current = items.findIndex(el => el.classList.contains('active'));
        let next;

        if (e.key === 'ArrowDown') {
          next = current === -1 ? 0 : Math.min(current + 1, items.length - 1);
        } else {
          next = current === -1 ? 0 : Math.max(current - 1, 0);
        }

        items.forEach((el, i) => el.classList.toggle('active', i === next));
        items[next]?.scrollIntoView({ block: 'nearest' });
      }

      // Enter to navigate
      if (e.key === 'Enter' && document.activeElement !== searchInput) {
        const active = document.querySelector('.nav-item.active');
        if (active) {
          location.hash = active.dataset.path;
        }
      }
    });

    // Search input handler
    document.getElementById('search').addEventListener('input', e => {
      buildNav(allFiles, e.target.value);
    });

    // Hash change handler
    window.addEventListener('hashchange', handleHashChange);

    // Initialize
    (async () => {
      try {
        allFiles = await loadFileList();
        buildNav(allFiles);

        if (location.hash) {
          await handleHashChange();
        }
      } catch (e) {
        document.getElementById('nav').innerHTML = `<div class="loading">Error: ${e.message}</div>`;
      }
    })();
  </script>
</body>
</html>
