import 'dart:io';

import 'package:sugar/sugar.dart';

import '../../../args/command.dart';
import '../../../configuration.dart';
import '../style.dart';
import 'command.dart';

const _unnamespaced = '''
import 'package:forui/forui.dart';
import 'package:flutter/material.dart';

/// Generated by Forui CLI.
///
/// Modify the generated function bodies to create your own custom style.
/// Then, call the modified functions and pass the results to your FThemeData.
/// 
/// ### Example
/// Generated style:
/// ```dart
/// // Modify this function's body.
/// FDividerStyles dividerStyles({
///   required FColorScheme color,
///   required FStyle style,
/// }) => FDividerStyles(
///   horizontalStyle: FDividerStyle(
///     colors: colors.secondary,
///     padding: FDividerStyle.defaultPadding.horizontalStyle,
///     width: style.borderWidth,
///   ),
///   verticalStyle: FDividerStyle(
///     colors: colors.secondary,
///     padding: FDividerStyle.defaultPadding.verticalStyle,
///     width: style.borderWidth,
///   ),
/// );

/// File that contains your `FThemeData`:
/// ```dart
/// import 'package:my_application/theme/divider_style.dart' // Your generated style file.
///
/// FThemeData(
///  color: FThemes.zinc.light.color,
///  style: FThemes.zinc.light.style,
///  dividerStyles: CustomFDividerStyles.dividerStyles( // The function in your generated style file.
///    color: FThemes.zinc.light.color,
///    style: FThemes.zinc.light.style,
///   ),
/// );
/// ```
///
/// A theme can be generated using the Forui CLI:
/// ```shell
/// dart forui theme create [theme name]
/// ```
/// 
/// See https://forui.dev/docs/themes#customize-themes for more information.''';

const _namespaced = '''
import 'package:forui/forui.dart';
import 'package:flutter/material.dart';

/// Generated by Forui CLI.
///
/// Modify the generated function bodies to create your own custom style.
/// Then, call the modified functions and pass the results to your FThemeData.
/// 
/// ### Example
/// Generated style:
/// ```dart
/// extension CustomFDividerStyles on Never {
///   // Modify this function's body.
///   static FDividerStyles dividerStyles({
///     required FColorScheme color,
///     required FStyle style,
///   }) => FDividerStyles(
///     horizontalStyle: FDividerStyle(
///       colors: colors.secondary,
///       padding: FDividerStyle.defaultPadding.horizontalStyle,
///       width: style.borderWidth,
///     ),
///     verticalStyle: FDividerStyle(
///       colors: colors.secondary,
///       padding: FDividerStyle.defaultPadding.verticalStyle,
///       width: style.borderWidth,
///     ),
///   );
/// }
/// ```
///
/// File that contains your `FThemeData`:
/// ```dart
/// import 'package:my_application/theme/divider_style.dart' // Your generated style file.
///
/// FThemeData(
///  color: FThemes.zinc.light.color,
///  style: FThemes.zinc.light.style,
///  dividerStyles: CustomFDividerStyles.dividerStyles( // The function in your generated style file.
///    color: FThemes.zinc.light.color,
///    style: FThemes.zinc.light.style,
///   ),
/// );
/// ```
/// 
/// A theme can be generated using the Forui CLI:
/// ```shell
/// dart forui theme create [theme name]
/// ```
/// 
/// See https://forui.dev/docs/themes#customize-themes for more information.''';

extension Generation on StyleCreateCommand {
  void generate(List<String> arguments, {required bool input, required bool all}) {
    final force = argResults!.flag('force');
    final output = argResults!['output'] as String;

    final paths = <String, List<String>>{};
    final existing = <String>{};

    for (final style in all ? Style.values.asNameMap().keys : arguments) {
      final fileName = registry[style.toLowerCase()]!.type.substring(1).toSnakeCase();
      final path =
          '${configuration.root.path}${Platform.pathSeparator}${output.endsWith('.dart') ? output : '$output${Platform.pathSeparator}$fileName.dart'}';

      (paths[path] ??= []).add(style);
      if (File(path).existsSync()) {
        existing.add(path);
      }
    }

    if (!force && existing.isNotEmpty) {
      _prompt(existing, input: input);
    }

    _generate(paths);

    stdout
      ..writeln()
      ..writeln('See https://forui.dev/docs/themes#customize-themes for more information.');
  }

  void _prompt(Set<String> existing, {required bool input}) {
    stdout.writeln('Found ${existing.length} file(s) that already exist.');

    if (!input) {
      stdout.writeln('Style files already exist. Skipping... ');
      exit(0);
    }

    stdout
      ..writeln()
      ..writeln('Existing files:');
    for (final path in existing) {
      stdout.writeln('  $path');
    }

    while (true) {
      stdout
        ..writeln()
        ..write('${emoji ? '⚠️' : '[Warning]'} Overwrite these files? [Y/n] ');

      switch (stdin.readLineSync()) {
        case 'y' || 'Y' || '':
          return;
        case 'n' || 'N':
          exit(0);
        default:
          stdout.writeln('Invalid option. Please enter enter either "y" or "n".');
      }
    }
  }

  void _generate(Map<String, List<String>> paths) {
    stdout
      ..writeln('${emoji ? '⏳' : '[Waiting]'} Creating styles...')
      ..writeln();

    for (final MapEntry(key: path, value: styles) in paths.entries) {
      final buffer = StringBuffer();

      if (registry[styles.singleOrNull] case Style(:final closure)) {
        buffer.writeln(_unnamespaced);
        _reduce(buffer, closure, many: false);
      } else {
        buffer.writeln(_namespaced);
        for (final style in styles) {
          _reduce(buffer, registry[style.toLowerCase()]!.closure, many: true);
        }
      }

      File(path)
        ..createSync(recursive: true)
        ..writeAsStringSync(formatter.format(buffer.toString()));

      stdout.writeln('${emoji ? '✅' : '[Done]'} $path');
    }
  }

  void _reduce(StringBuffer buffer, List<String> closure, {required bool many}) {
    final root = registry[closure.first.toLowerCase()]!;

    if (many) {
      buffer
        ..writeln('extension Custom${root.type} on Never {')
        ..write('static ');
    }
    buffer.writeln(root.source);

    for (final nested in closure.skip(1)) {
      if (many) {
        buffer.write('static ');
      }
      final style = registry[nested.toLowerCase()]!;
      buffer.write(
        '${style.source.substring(0, style.type.length + 1)}_${style.source.substring(style.type.length + 1)}\n',
      );
    }

    if (many) {
      buffer.writeln('}');
    }
  }
}
